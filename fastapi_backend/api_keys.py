import os\nfrom typing import Optional, Dict, Any\nfrom cryptography.fernet import Fernet\nfrom functools import lru_cache\nimport logging\n\nlogger = logging.getLogger(__name__)\n\nclass APIKeyManager:\n    \"\"\"Secure API key management with encryption and rotation support\"\"\"\n    \n    def __init__(self):\n        self.encryption_key = self._get_or_create_encryption_key()\n        self.cipher_suite = Fernet(self.encryption_key)\n    \n    def _get_or_create_encryption_key(self) -> bytes:\n        \"\"\"Get or create encryption key for API keys\"\"\"\n        key_file = \".encryption_key\"\n        \n        if os.path.exists(key_file):\n            with open(key_file, \"rb\") as f:\n                return f.read()\n        else:\n            # Generate new key\n            key = Fernet.generate_key()\n            with open(key_file, \"wb\") as f:\n                f.write(key)\n            # Set restrictive permissions\n            os.chmod(key_file, 0o600)\n            return key\n    \n    def encrypt_api_key(self, api_key: str) -> str:\n        \"\"\"Encrypt an API key for storage\"\"\"\n        encrypted_key = self.cipher_suite.encrypt(api_key.encode())\n        return encrypted_key.decode()\n    \n    def decrypt_api_key(self, encrypted_key: str) -> str:\n        \"\"\"Decrypt an API key for use\"\"\"\n        decrypted_key = self.cipher_suite.decrypt(encrypted_key.encode())\n        return decrypted_key.decode()\n    \n    @lru_cache(maxsize=32)\n    def get_api_key(self, service_name: str) -> Optional[str]:\n        \"\"\"Get API key for a service (cached)\"\"\"\n        env_var = f\"{service_name.upper()}_API_KEY\"\n        encrypted_key = os.getenv(env_var)\n        \n        if not encrypted_key:\n            logger.warning(f\"API key not found for service: {service_name}\")\n            return None\n        \n        try:\n            # Try to decrypt (for encrypted keys)\n            return self.decrypt_api_key(encrypted_key)\n        except Exception:\n            # Fallback to plain text (for development)\n            logger.warning(f\"Using plain text API key for {service_name} (development only)\")\n            return encrypted_key\n    \n    def validate_api_key(self, service_name: str) -> bool:\n        \"\"\"Validate that an API key exists and is accessible\"\"\"\n        try:\n            key = self.get_api_key(service_name)\n            return key is not None and len(key.strip()) > 0\n        except Exception as e:\n            logger.error(f\"Error validating API key for {service_name}: {e}\")\n            return False\n    \n    def rotate_api_key(self, service_name: str, new_key: str) -> bool:\n        \"\"\"Rotate an API key (encrypt and update environment)\"\"\"\n        try:\n            encrypted_key = self.encrypt_api_key(new_key)\n            env_var = f\"{service_name.upper()}_API_KEY\"\n            \n            # In production, this would update your secrets management system\n            # For development, you might update a .env file\n            logger.info(f\"API key rotated for service: {service_name}\")\n            \n            # Clear cache\n            self.get_api_key.cache_clear()\n            \n            return True\n        except Exception as e:\n            logger.error(f\"Error rotating API key for {service_name}: {e}\")\n            return False\n\n# Global instance\napi_key_manager = APIKeyManager()\n\n# External service integrations\nclass ExternalServiceClient:\n    \"\"\"Base class for external service clients with secure API key handling\"\"\"\n    \n    def __init__(self, service_name: str):\n        self.service_name = service_name\n        self.api_key = api_key_manager.get_api_key(service_name)\n        \n        if not self.api_key:\n            raise ValueError(f\"API key not configured for service: {service_name}\")\n    \n    def get_headers(self) -> Dict[str, str]:\n        \"\"\"Get headers with API key\"\"\"\n        return {\n            \"Authorization\": f\"Bearer {self.api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n\nclass YFinanceClient(ExternalServiceClient):\n    \"\"\"Yahoo Finance API client\"\"\"\n    \n    def __init__(self):\n        # YFinance doesn't require API key, but keeping for consistency\n        self.service_name = \"yfinance\"\n        # Skip parent init for YFinance as it doesn't need API key\n    \n    async def get_stock_data(self, symbol: str) -> Dict[str, Any]:\n        \"\"\"Get stock data from Yahoo Finance\"\"\"\n        import yfinance as yf\n        \n        try:\n            ticker = yf.Ticker(symbol)\n            info = ticker.info\n            \n            return {\n                \"symbol\": symbol,\n                \"price\": info.get(\"currentPrice\", 0),\n                \"change\": info.get(\"regularMarketChange\", 0),\n                \"change_percent\": info.get(\"regularMarketChangePercent\", 0),\n                \"volume\": info.get(\"regularMarketVolume\", 0)\n            }\n        except Exception as e:\n            logger.error(f\"Error fetching stock data for {symbol}: {e}\")\n            raise\n\nclass AlphaVantageClient(ExternalServiceClient):\n    \"\"\"Alpha Vantage API client\"\"\"\n    \n    def __init__(self):\n        super().__init__(\"alphavantage\")\n        self.base_url = \"https://www.alphavantage.co/query\"\n    \n    async def get_stock_quote(self, symbol: str) -> Dict[str, Any]:\n        \"\"\"Get real-time stock quote\"\"\"\n        import aiohttp\n        \n        params = {\n            \"function\": \"GLOBAL_QUOTE\",\n            \"symbol\": symbol,\n            \"apikey\": self.api_key\n        }\n        \n        try:\n            async with aiohttp.ClientSession() as session:\n                async with session.get(self.base_url, params=params) as response:\n                    data = await response.json()\n                    \n                    if \"Global Quote\" in data:\n                        quote = data[\"Global Quote\"]\n                        return {\n                            \"symbol\": quote.get(\"01. symbol\"),\n                            \"price\": float(quote.get(\"05. price\", 0)),\n                            \"change\": float(quote.get(\"09. change\", 0)),\n                            \"change_percent\": quote.get(\"10. change percent\", \"0%\")\n                        }\n                    else:\n                        raise ValueError(f\"Invalid response from Alpha Vantage: {data}\")\n        except Exception as e:\n            logger.error(f\"Error fetching quote for {symbol}: {e}\")\n            raise\n\n# Service factory\ndef get_market_data_client(provider: str = \"yfinance\"):\n    \"\"\"Get market data client based on provider\"\"\"\n    if provider == \"yfinance\":\n        return YFinanceClient()\n    elif provider == \"alphavantage\":\n        return AlphaVantageClient()\n    else:\n        raise ValueError(f\"Unsupported market data provider: {provider}\")\n\n# Health check for external services\nasync def check_external_services() -> Dict[str, bool]:\n    \"\"\"Check health of external services\"\"\"\n    services = {}\n    \n    # Check YFinance\n    try:\n        client = YFinanceClient()\n        await client.get_stock_data(\"AAPL\")\n        services[\"yfinance\"] = True\n    except Exception:\n        services[\"yfinance\"] = False\n    \n    # Check Alpha Vantage (if configured)\n    try:\n        if api_key_manager.validate_api_key(\"alphavantage\"):\n            client = AlphaVantageClient()\n            await client.get_stock_quote(\"AAPL\")\n            services[\"alphavantage\"] = True\n        else:\n            services[\"alphavantage\"] = False\n    except Exception:\n        services[\"alphavantage\"] = False\n    \n    return services